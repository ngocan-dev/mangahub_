// Code generated by protoc-gen-go. DO NOT EDIT.
// This is a simplified version for manual implementation
// In production, use: protoc --go_out=. --go-grpc_out=. proto/manga.proto

package manga

import (
	"context"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// NewMangaServiceClient creates a new MangaServiceClient.
func NewMangaServiceClient(cc grpc.ClientConnInterface) MangaServiceClient {
	return &mangaServiceClient{cc}
}

type mangaServiceClient struct {
	cc grpc.ClientConnInterface
}

func (c *mangaServiceClient) GetManga(ctx context.Context, in *GetMangaRequest, opts ...grpc.CallOption) (*GetMangaResponse, error) {
	out := new(GetMangaResponse)
	err := c.cc.Invoke(ctx, "/manga.MangaService/GetManga", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mangaServiceClient) SearchManga(ctx context.Context, in *SearchMangaRequest, opts ...grpc.CallOption) (*SearchMangaResponse, error) {
	out := new(SearchMangaResponse)
	err := c.cc.Invoke(ctx, "/manga.MangaService/SearchManga", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mangaServiceClient) UpdateProgress(ctx context.Context, in *UpdateProgressRequest, opts ...grpc.CallOption) (*UpdateProgressResponse, error) {
	out := new(UpdateProgressResponse)
	err := c.cc.Invoke(ctx, "/manga.MangaService/UpdateProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MangaServiceClient is the client API for MangaService service
type MangaServiceClient interface {
	GetManga(ctx context.Context, in *GetMangaRequest, opts ...grpc.CallOption) (*GetMangaResponse, error)
	SearchManga(ctx context.Context, in *SearchMangaRequest, opts ...grpc.CallOption) (*SearchMangaResponse, error)
	UpdateProgress(ctx context.Context, in *UpdateProgressRequest, opts ...grpc.CallOption) (*UpdateProgressResponse, error)
}

// MangaServiceServer is the server API for MangaService service
type MangaServiceServer interface {
	GetManga(context.Context, *GetMangaRequest) (*GetMangaResponse, error)
	SearchManga(context.Context, *SearchMangaRequest) (*SearchMangaResponse, error)
	UpdateProgress(context.Context, *UpdateProgressRequest) (*UpdateProgressResponse, error)
	mustEmbedUnimplementedMangaServiceServer()
}

// UnimplementedMangaServiceServer must be embedded to have forward compatible implementations
type UnimplementedMangaServiceServer struct{}

func (UnimplementedMangaServiceServer) GetManga(context.Context, *GetMangaRequest) (*GetMangaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetManga not implemented")
}

func (UnimplementedMangaServiceServer) SearchManga(context.Context, *SearchMangaRequest) (*SearchMangaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchManga not implemented")
}

func (UnimplementedMangaServiceServer) UpdateProgress(context.Context, *UpdateProgressRequest) (*UpdateProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProgress not implemented")
}

func (UnimplementedMangaServiceServer) mustEmbedUnimplementedMangaServiceServer() {}

// RegisterMangaServiceServer registers the MangaServiceServer with the gRPC server
func RegisterMangaServiceServer(s *grpc.Server, srv MangaServiceServer) {
	s.RegisterService(&MangaService_ServiceDesc, srv)
}

// MangaService_ServiceDesc is the grpc.ServiceDesc for MangaService service
var MangaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manga.MangaService",
	HandlerType: (*MangaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetManga",
			Handler:    _MangaService_GetManga_Handler,
		},
		{
			MethodName: "SearchManga",
			Handler:    _MangaService_SearchManga_Handler,
		},
		{
			MethodName: "UpdateProgress",
			Handler:    _MangaService_UpdateProgress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manga.proto",
}

func _MangaService_GetManga_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMangaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MangaServiceServer).GetManga(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manga.MangaService/GetManga",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MangaServiceServer).GetManga(ctx, req.(*GetMangaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MangaService_SearchManga_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMangaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MangaServiceServer).SearchManga(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manga.MangaService/SearchManga",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MangaServiceServer).SearchManga(ctx, req.(*SearchMangaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MangaService_UpdateProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MangaServiceServer).UpdateProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manga.MangaService/UpdateProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MangaServiceServer).UpdateProgress(ctx, req.(*UpdateProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GetMangaRequest is the request message
type GetMangaRequest struct {
	MangaId int64 `protobuf:"varint,1,opt,name=manga_id,json=mangaId,proto3" json:"manga_id,omitempty"`
}

// GetMangaResponse is the response message
type GetMangaResponse struct {
	Manga *Manga `protobuf:"bytes,1,opt,name=manga,proto3" json:"manga,omitempty"`
}

// SearchMangaRequest is the request message
type SearchMangaRequest struct {
	Query  string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Genre  string `protobuf:"bytes,2,opt,name=genre,proto3" json:"genre,omitempty"`
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	Page   int32  `protobuf:"varint,4,opt,name=page,proto3" json:"page,omitempty"`
	Limit  int32  `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
}

// SearchMangaResponse is the response message
type SearchMangaResponse struct {
	Results []*Manga `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	Total   int32    `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	Page    int32    `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	Limit   int32    `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	Pages   int32    `protobuf:"varint,5,opt,name=pages,proto3" json:"pages,omitempty"`
}

// UpdateProgressRequest is the request message
type UpdateProgressRequest struct {
	UserId         int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	MangaId        int64 `protobuf:"varint,2,opt,name=manga_id,json=mangaId,proto3" json:"manga_id,omitempty"`
	CurrentChapter int32 `protobuf:"varint,3,opt,name=current_chapter,json=currentChapter,proto3" json:"current_chapter,omitempty"`
}

// UpdateProgressResponse is the response message
type UpdateProgressResponse struct {
	Success        bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message        string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	CurrentChapter int32  `protobuf:"varint,3,opt,name=current_chapter,json=currentChapter,proto3" json:"current_chapter,omitempty"`
	Broadcasted    bool   `protobuf:"varint,4,opt,name=broadcasted,proto3" json:"broadcasted,omitempty"`
}

// Manga represents manga information
type Manga struct {
	Id           int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Title        string   `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Author       string   `protobuf:"bytes,4,opt,name=author,proto3" json:"author,omitempty"`
	Description  string   `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	CoverImage   string   `protobuf:"bytes,6,opt,name=cover_image,json=coverImage,proto3" json:"cover_image,omitempty"`
	Status       string   `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	ChapterCount int32    `protobuf:"varint,8,opt,name=chapter_count,json=chapterCount,proto3" json:"chapter_count,omitempty"`
	Genres       []string `protobuf:"bytes,9,rep,name=genres,proto3" json:"genres,omitempty"`
	CreatedAt    string   `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt    string   `protobuf:"bytes,11,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}
